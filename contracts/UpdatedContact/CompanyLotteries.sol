// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./LotteryStructs.sol";
import "./TicketToken.sol";

/*
    The CompanyLotteries contract manages a lottery system that uses an ERC20 token (represented by the TicketToken contract)
    for ticket purchases. It allows for the creation of lotteries, ticket purchases, random number revelations, state changes, and more.
    The contract tracks multiple lotteries, their state, the participants, and the tickets they purchase.
    It also includes functionality for updating lottery states, revealing winners, and handling refunds in case of cancellations.
*/
contract CompanyLotteries {
    using LotteryStructs for *; // Using the Lottery, Ticket structs and LotteryState enum

    TicketToken public ticketToken;
    address public owner;
    uint256 public currentLotteryNo;
    LotteryStructs.Lottery[] lotteries;
    mapping(uint256 => LotteryStructs.Ticket[]) public lotteryTickets; // Mapping of lottery IDs to an array of TicketInfo structs
    /*
    Sets the owner and initializes TicketToken contract.
    @param _ticketTokenAddress address of the deployed TicketToken contract
    */
    constructor(address _ticketTokenAddress) {
        owner = msg.sender;
        ticketToken = TicketToken(_ticketTokenAddress);
    }

    // Modifier to control functions that can be called by the owner only
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    // Events
    event LotteryCreated(uint lottery_no, uint unixbeg, uint nooftickets); // Track created lotteries

    // Event to notify that winners have been determined
    event WinnersDetermined(uint256 lottery_no, uint256[] winners);

   /*
    Creates a new lottery with Lottery Struct.
    @param unixbeg End time of the lottery (in Unix timestamp)
    @param noOfTickets Total number of tickets in the lottery
    @param noOfWinners Number of winners to be selected
    @param minPercentage Minimum percentage of tickets to be sold for the lottery to be valid
    @param ticketPrice Price of each ticket (in the NBG Token)
    @returns currentLotteryNo Lottery number of created lottery
    */
    function createLottery(
        uint unixbeg,
        uint nooftickets,
        uint noofwinners,
        uint minpercentage,
        uint ticketprice,
        bytes32 htmlhash,
        string memory url
    ) public onlyOwner returns (uint lottery_no) {

    require(noofwinners > 0, "At least one winner required!");
    require(minpercentage <= 100, "Min participation cannot exceed 100!");
    
    uint256 currenttime = block.timestamp;
    require(unixbeg > currenttime, "Lottery end time must be in the future.");
    currentLotteryNo++;

    lotteries.push(LotteryStructs.Lottery({
        unixbeg: unixbeg,
        nooftickets: nooftickets,
        noofwinners: noofwinners,
        minpercentage: minpercentage,
        ticketprice: ticketprice,
        htmlhash: htmlhash,
        url: url,
        revealStartTime: currenttime + ((unixbeg - currenttime) / 2),  // half the time of total
        state: LotteryStructs.LotteryState.PURCHASE,
        numsold: 0,
        numpurchasetxs: 0,
        currentRandom: 0,
        lotteryWinners: new uint256[](noofwinners)  // Initialize winners array with the number of winners
    }));

   
    emit LotteryCreated(currentLotteryNo, unixbeg, nooftickets);

    return currentLotteryNo;

    }
  /*
    Allows a user to purchase tickets for a specified lottery.
    This function ensures the lottery is active, there are enough tickets available, 
    and processes the purchase by transferring the total cost in tokens.
    It also creates a ticket for the user and updates the lottery state.
    @param lottery_no Lottery which the ticket will be purchased
    @param quantity Number of tickets to be purchased
    @param hash_rnd_number Hash generated by the user by using their address and random number
    @return sticketno The ticket number for the first ticket purchased (the index of the first ticket in the array).
    Emits a `TicketPurchased` event to track the ticket purchase.
    */
    function buyTicketTx(
        uint lottery_no,
        uint quantity,
        bytes32 hash_rnd_number
    ) public returns (uint sticketno) {
        // Check if the lottery is active, lottery is finished, and are there enough tickets to sold
        require(
            lotteries[lottery_no].state == LotteryStructs.LotteryState.PURCHASE,
            "Lottery is not active"
        );
        require(
            block.timestamp < lotteries[lottery_no].revealStartTime,
            "Lottery sale is done"
        );
        require(
            lotteries[lottery_no].numsold + quantity <= lotteries[lottery_no].nooftickets,
            "Not enough tickets available"
        );


        // Calculate total cost and transfer token from user to the company account.
        uint256 totalCost = quantity * lotteries[lottery_no].ticketprice;
        ticketToken.transferFrom(msg.sender, address(this), totalCost);

        lotteries[lottery_no].numsold += quantity;
        //update purchase transactions
        lotteries[lottery_no].numpurchasetxs += 1;

        lotteryTickets[lottery_no].push(LotteryStructs.Ticket({
            owner: msg.sender,
            quantity: quantity,
            hash: keccak256(abi.encodePacked(hash_rnd_number, sticketno, quantity, msg.sender)),
            revealed: false,
            redeemed: false
        }));
    sticketno =  uint32(lotteryTickets[lottery_no].length);
        
    }

    /*
    Allows a ticket owner to reveal their random number for a lottery.
    Verifies the ticket's ownership, quantity, and the hash of the provided random number.
    @param lottery_no The ID of the lottery where the ticket belongs.
    @param sticketno The ticket number to reveal the random number for.
    @param quantity The number of tickets purchased (should match the ticket's quantity).
    @param rnd_number The random number provided by the ticket holder to be revealed.
    */
    function revealRndNumberTx(
        uint lottery_no,
        uint sticketno,
        uint quantity,
        uint rnd_number
    ) public {
        require(
            sticketno < lotteryTickets[lottery_no].length,
            "Ticket does not exist"
        );
        // Verify that hash of provided rnd_number matches the committed hash
        require(
            (lotteryTickets[lottery_no][sticketno].hash == keccak256(abi.encodePacked(rnd_number, lottery_no, sticketno, msg.sender))),
            "You revealed a wrong number, make sure to reveal the number you submitted"
        );
        lotteryTickets[lottery_no][sticketno].revealed = true;
        lotteries[lottery_no].currentRandom ^= rnd_number;
    }

    /*
    Retrieves the number of purchase Transactions a specific lottery.
    @param lottery_no Lottery ID which is used to retrieve information about its transactions.
    @return numpurchasetxs Number of transactions
    */
    function getNumPurchaseTxs(uint lottery_no) public view returns (uint numpurchasetxs) {
        return lotteries[lottery_no].numpurchasetxs;
    }

    /*
    View function to get information of a ticket.
    Allows anyone to view the quantity of tickets purchased in the Ith transaction for a specified lottery
    @param i Ticket index number (starts with 1 as first)
    @param lottery_no lottery number which the ticket is in
    @return sTicketNo Sold ticket no
    @return quantity Quantity of tickets sold
    */
    function getIthPurchasedTicketTx(uint i, uint lottery_no) public view returns (uint sticketno, uint quantity) {
        // Check if the number of ticket is more than total ticket sold
        require(i < lotteryTickets[lottery_no].length, "Index out of range");
        // Access the ticket information
        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][i];
        return (i, ticket.quantity);
    }

    /*
    Function to check if a specific ticket has won in a specified lottery.
    This function assumes the winners are determined and marked in some way 
    @param lottery_no The ID of the lottery.
    @param ticket_no The ticket number to check (starting from 0 for the first ticket).
    @return won A boolean indicating whether the specified ticket has won.   
    */
    function checkIfMyTicketWon(uint lottery_no, uint ticket_no) public view returns (bool won) {
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");
        require(
            ticket_no < lotteryTickets[lottery_no].length,
            "Invalid ticket number"
        );
        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][ticket_no];
        // Verify that the caller owns the ticket
        require(ticket.owner == msg.sender, "You do not own this ticket");

        // Check if ticketNo is in the list of winners for the lottery
        for (uint256 i = 0; i < lotteries[lottery_no].lotteryWinners.length;i++) {
            if (lotteries[lottery_no].lotteryWinners[i] == ticket_no) {
                return true;
            }
        }
        return false;
    }

    /*
    Checks if a specific ticket owned by a given address has won in a specified lottery.
    @param addr The address of the ticket owner.
    @param lottery_no The ID of the lottery.
    @param ticket_no The ticket number to check (starting from 0 for the first ticket).
    @return won A boolean indicating whether the specified ticket has won.
    */
    function checkIfAddrTicketWon(address addr, uint lottery_no, uint ticket_no) public view returns (bool won){
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");
        require(ticket_no < lotteryTickets[lottery_no].length,"Invalid ticket number");

        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][ticket_no];

        // Verify that the ticket belongs to the specified address
        require(ticket.owner == addr, "The specified address does not own this ticket");

        // Check if ticketNo is in the list of winners for the lottery
        for (uint256 i = 0; i < lotteries[lottery_no].lotteryWinners.length;i++) {
            if (lotteries[lottery_no].lotteryWinners[i] == ticket_no) {
                return true;
            }
        }
        return false;
    }


    /*
    Retrieves the ticket number of the i-th winning ticket in a specific lottery.
    @param lottery_no The ID of the lottery.
    @param i The index of the winning ticket (starting from 1 for the first winner).
    @return ticketno The ticket number of the i-th winner.
    */
    function getIthWinningTicket(uint lottery_no, uint i) public view returns (uint ticketno) {
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");
        require(
            lotteries[lottery_no].state == LotteryStructs.LotteryState.COMPLETED,
            "Lottery has not been completed"
        );
        // Ensure the i-th winner index is within the number of winners
        require(i > 0 && i <= lotteries[lottery_no].noofwinners, "Invalid winner index");
        // Adjust index to match array (0-based index)
        uint winnerIndex = i - 1;
        // Retrieve the winning ticket's index
        ticketno = lotteries[lottery_no].lotteryWinners[winnerIndex];
        return ticketno;
}

    /*
    Allows a ticket owner to withdraw a refund if the lottery was canceled or failed to meet its minimum ticket sales requirement.
    @param lottery_no The ID of the lottery.
    @param sticket_no The ticket number for which the refund is being claimed.
    */
    function withdrawTicketRefund(uint lottery_no, uint sticket_no) public {
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        LotteryStructs.Lottery storage lottery = lotteries[lottery_no];

        // Ensure the lottery is in a refundable state
        require(
            lottery.state == LotteryStructs.LotteryState.CANCELLED || 
            (lottery.state != LotteryStructs.LotteryState.COMPLETED && 
            block.timestamp > lottery.unixbeg && 
            lottery.numsold < (lottery.nooftickets * lottery.minpercentage) / 100),
            "Refunds not available for this lottery"
        );

        require(sticket_no < lotteryTickets[lottery_no].length, "Invalid ticket number");

        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][sticket_no];

        // Ensure the caller owns the ticket
        require(ticket.owner == msg.sender, "Caller is not the owner of this ticket");
        // Ensure the ticket hasn't been refunded already
        require(!ticket.redeemed, "Ticket already refunded");
        // Calculate refund amount
        uint256 refundAmount = ticket.quantity * lottery.ticketprice;
        // Mark the ticket as redeemed
        ticket.redeemed = true;
        // Transfer refund to the ticket owner
        require(ticketToken.transfer(msg.sender, refundAmount), "Refund transfer failed");

    }

    /*
        Returns the current lottery number of the contract.
        @return currentLotteryNo Current Lottery number in the contract.
    */
    function getCurrentLotteryNo() public view returns (uint lottery_no) {
        return currentLotteryNo;
    }

    /*
    Allows the contract owner to withdraw the ticket proceeds from a specific lottery.
    This function is only callable by the contract owner and will transfer the proceeds to the owner's address.
    @param lottery_no The ID of the lottery for which the proceeds are being withdrawn.
    */
    function withdrawTicketProceeds(uint lottery_no) public onlyOwner {
        // Ensure the lottery exists and is completed
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        require(
            lotteries[lottery_no].state == LotteryStructs.LotteryState.COMPLETED,
            "Lottery has not been completed"
        );

        LotteryStructs.Lottery storage lottery = lotteries[lottery_no];

        // Calculate the total ticket sales proceeds
        uint256 totalProceeds = lottery.numsold * lottery.ticketprice;

        // Ensure the contract has sufficient funds (assuming ticket sales are in ERC20 tokens)
        uint256 contractBalance = ticketToken.balanceOf(address(this));
        require(contractBalance >= totalProceeds, "Insufficient funds in contract");

        // Transfer the ticket proceeds to the contract owner
        require(ticketToken.transfer(owner, totalProceeds), "Proceeds transfer failed");
    }


    /*
    Allows the contract owner to set or update the address of the ERC20 token used for ticket purchases.
    @param erctokenaddr The address of the new ERC20 token contract to be used for ticket payments.
    */
    function setPaymentToken(address erctokenaddr) public onlyOwner {
        require(erctokenaddr != address(0), "Invalid token address");
        // Set the new ERC20 token address
        ticketToken = TicketToken(erctokenaddr);
    }

    /*
    Retrieves the ERC20 token address used for ticket purchases in a specific lottery.
    @param lottery_no The ID of the lottery for which the payment token address is being retrieved.
    @return erctokenaddr The ERC20 token address used for ticket purchases in the specified lottery.
    */
    function getPaymentToken(uint lottery_no) public view returns (address erctokenaddr) {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");
     
    
        // Return the ERC20 token address used for ticket purchases in the specified lottery
        erctokenaddr = address(ticketToken);
    }

    /*
        Retrieves the essential information about a specific lottery based on its unique lottery ID
        @param lottery_no The ID of the lottery whose information is being requested
        @return unixbeg Start time of the lottery (in Unix timestamp)
        @return noOfTickets Total number of tickets in the lottery
        @return noOfWinners Number of winners to be selected
        @return minPercentage Minimum percentage of tickets to be sold for the lottery to be valid
        @return ticketPrice Price of each ticket (in the NBG Token)
    */
    function getLotteryInfo(uint256 lottery_no) public view
        returns (
            uint256 unixbeg,
            uint256 nooftickets,
            uint256 noofwinners,
            uint256 minpercentage,
            uint256 ticketprice
        )
    {
            // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        // Access the LotteryInfo struct for the specified lottery number
        LotteryStructs.Lottery storage lottery = lotteries[lottery_no];
        return (
            lottery.unixbeg,
            lottery.nooftickets,
            lottery.noofwinners,
            lottery.minpercentage,
            lottery.ticketprice
        );
    }

    /*
    Retrieves the URL and the associated hash (HTML hash) for a given lottery.
    This function allows users to fetch the URL and the HTML hash linked to a specific lottery.
 
    @param lottery_no The ID of the lottery whose URL and HTML hash are being queried.
                      It corresponds to a specific lottery stored in the `lotteries` mapping.

    @return htmlhash The bytes32 hash of the HTML content related to the lottery. This could represent a hash of a web page or resource related to the lottery.
    @return url The string URL associated with the lottery. This could be the link to the lottery's page or additional information about the lottery.
    */
    function getLotteryURL(uint lottery_no) public view returns (bytes32 htmlhash, string memory url) {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        LotteryStructs.Lottery storage lottery = lotteries[lottery_no];
        return (lottery.htmlhash, lottery.url);
    }

    /*
    Retrieves the number of ticket sold for a specific lottery.
    @param lottery_no Lottery ID which is used to retrieve information about its state and sold tickets
    @return soldTickets Number of purchased tickets in that particular lottery
    */
    function getLotterySales(uint lottery_no) public view returns (uint numsold)
    {   // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        return lotteries[lottery_no].numsold;
    }

    /*
    Determines the winners of a specific lottery. This function assumes that winners are selected
    based on a predetermined random number or another method.
    @param lottery_no The ID of the lottery for which the winners will be determined.
    @return winner_ticket_numbers An array of ticket numbers representing the winners.
    */
    function determineWinners(uint256 lottery_no) external onlyOwner {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");

        LotteryStructs.Lottery storage lottery = lotteries[lottery_no];

        // Ensure lottery is in the appropriate state
        require(lottery.state == LotteryStructs.LotteryState.COMPLETED, "Lottery has not been completed");

        // Ensure enough tickets were sold if a minimum percentage is required
        uint256 minTicketsRequired = (lottery.nooftickets * lottery.minpercentage) / 100;
        require(lottery.numsold >= minTicketsRequired, "Not enough tickets sold to determine winners");

        uint256 totalTickets = lottery.numsold;
        uint256 numWinners = lottery.noofwinners;

        // Use currentRandom as the seed for winner determination
        uint256 randomSeed = lottery.currentRandom;

        // Select winners
        for (uint256 i = 0; i < numWinners; i++) {
            // Generate a pseudo-random number
            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(randomSeed, i))) % totalTickets;
            // Ensure the winner is unique
            while (arrayContains(lottery.lotteryWinners, winnerIndex)) {
                winnerIndex = (winnerIndex + 1) % totalTickets;
            }
            // Add the winner to the list
            lottery.lotteryWinners[i] = winnerIndex;
        }
        // Emit an event for winner determination
        emit WinnersDetermined(lottery_no, lottery.lotteryWinners);
    }

    // Helper function to check if an array contains a specific value
    function arrayContains(uint256[] memory array, uint256 value) private pure returns (bool) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == value) {
                return true;
            }
        }
        return false;
    }

    /*
    Updates the state of the lottery based on time and conditions.
    This function ensures that the lottery transitions through valid states:
        - `PURCHASE` -> `REVEAL` (when the reveal time is reached)
        - `REVEAL` -> `COMPLETED` (when the lottery end time is reached)
        - `CANCELLED` (if the minimum percentage of tickets is not sold)
    
    @param lottery_no The ID of the lottery whose state is being updated.
    */
    function updateLotteryState(uint256 lottery_no) public view onlyOwner {
        // Check that the lottery exists
        require(lotteries[lottery_no].unixbeg != 0, "Lottery does not exist");
        // Ensure valid state transitions PURCHASE -> REVEAL
        if (
            (lotteries[lottery_no].state ==
                LotteryStructs.LotteryState.PURCHASE) &&
            (block.timestamp >= lotteries[lottery_no].revealStartTime)
        ) {
            lotteries[lottery_no].state == LotteryStructs.LotteryState.REVEAL;
        }
        // Ensure valid state transitions REVEAL -> COMPLETED
        if (
            (lotteries[lottery_no].state ==
                LotteryStructs.LotteryState.REVEAL) &&
            (block.timestamp >= lotteries[lottery_no].unixbeg)
        ) {
            lotteries[lottery_no].state ==
                LotteryStructs.LotteryState.COMPLETED;
        }
        // Ensure valid state transitions CANCELLATION
        uint256 soldpercentage = (lotteries[lottery_no].numsold /
            lotteries[lottery_no].nooftickets) * 100;
        if (
            (lotteries[lottery_no].minpercentage > soldpercentage) &&
            (block.timestamp >= lotteries[lottery_no].revealStartTime)
        ) {
            lotteries[lottery_no].state ==
                LotteryStructs.LotteryState.CANCELLED;
        }
    }

    /**
    * Updates the states of all lotteries based on current conditions.
    * Transitions include:
    * - PURCHASE ➔ REVEAL if revealStartTime is reached.
    * - REVEAL ➔ COMPLETED if unixbeg is reached and minimum tickets are sold.
    * - Any state ➔ CANCELLED if unixbeg is reached and minimum tickets are not sold.
    */
    function updateLotteryStates() public {
        uint256 currentTime = block.timestamp;

        for (uint256 i = 1; i <= currentLotteryNo; i++) {
            LotteryStructs.Lottery storage lottery = lotteries[i];

            if (lottery.state == LotteryStructs.LotteryState.PURCHASE) {
                // Transition to REVEAL if revealStartTime is reached
                if (currentTime >= lottery.revealStartTime) {
                    lottery.state = LotteryStructs.LotteryState.REVEAL;
                }
            } else if (lottery.state == LotteryStructs.LotteryState.REVEAL) {
                // Transition to COMPLETED if enough tickets sold, else CANCELLED
                if (currentTime >= lottery.unixbeg) {
                    uint256 minTicketsRequired = (lottery.nooftickets * lottery.minpercentage) / 100;
                    if (lottery.numsold >= minTicketsRequired) {
                        lottery.state = LotteryStructs.LotteryState.COMPLETED;
                    } else {
                        lottery.state = LotteryStructs.LotteryState.CANCELLED;
                    }
                }
            } else if (
                lottery.state == LotteryStructs.LotteryState.PURCHASE ||
                lottery.state == LotteryStructs.LotteryState.REVEAL
            ) {
                // Cancel lotteries if end time passed and they haven't transitioned
                if (currentTime >= lottery.unixbeg) {
                    uint256 minTicketsRequired = (lottery.nooftickets * lottery.minpercentage) / 100;
                    if (lottery.numsold < minTicketsRequired) {
                        lottery.state = LotteryStructs.LotteryState.CANCELLED;
                    }
                }
            }
        }  
    }


}