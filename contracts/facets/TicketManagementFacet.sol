// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "../libraries/LotteryStorage.sol";
import "../libraries/LotteryStructs.sol";
import "../TicketToken.sol"; // Import the ERC20 ticket payment token

/**
 * TicketManagementFacet
 * Facet responsible for managing ticket purchases, refunds, and related queries.
 */
contract TicketManagementFacet {

    // Modifier to control lottery number
    modifier lotteryControl(uint lottery_no) {
        LotteryStorage.State storage s = LotteryStorage.getStorage();
        require(lottery_no > 0 && lottery_no-1 <= s.currentLotteryNo, "Invalid lottery number");
        _;
    }

    /**
    * Allows a user to purchase tickets for a specified lottery.
    * This function ensures the lottery is active, there are enough tickets available, 
    * and processes the purchase by transferring the total cost in tokens.
    * It also creates a ticket for the user and updates the lottery state.
    * @param lottery_no Lottery which the ticket will be purchased
    * @param quantity Number of tickets to be purchased
    * @param hash_rnd_number Hash generated by the user by using their address and random number
    * @return sticketno The ticket number for the first ticket purchased (the index of the first ticket in the array).
    * Emits a `TicketPurchased` event to track the ticket purchase.
    */
    function buyTicketTx(
        uint lottery_no,
        uint quantity,
        bytes32 hash_rnd_number
    )   public
        lotteryControl(lottery_no)
        returns (uint sticketno) {

        LotteryStorage.State storage s = LotteryStorage.getStorage();
        LotteryStructs.Lottery storage lottery = s.lotteries[lottery_no-1];
        
        // Check if the lottery is active, lottery is finished, and are there enough tickets to sold
        require(lottery.state == LotteryStructs.LotteryState.PURCHASE, "Lottery is not active");
        require(block.timestamp < lottery.revealStartTime, "Lottery sale is done");
        require(quantity > 0 && quantity <= 30, "You can purchase at most 30 tickets. ");
        require(lottery.numsold + quantity <= lottery.nooftickets,"Not enough tickets available");

        // Calculate total cost and transfer token from user to the company account.
        uint256 totalCost = quantity * lottery.ticketprice;

        // Transfer token from  msg.sender to company address.
        TicketToken ticketToken = TicketToken(address(this));
        require(ticketToken.transferFrom(msg.sender, address(this), totalCost), "Payment failed");

        // Update lottery details
        lottery.numsold += quantity;
        lottery.numpurchasetxs++;

        // Add ticket details
        LotteryStructs.Ticket memory newTicket = LotteryStructs.Ticket({
            owner: msg.sender,
            quantity: quantity,
            hash: keccak256(abi.encodePacked(hash_rnd_number, msg.sender)),
            revealed: false,
            redeemed: false
        });

        s.lotteryTickets[lottery_no].push(newTicket);
        sticketno =  uint32(s.lotteryTickets[lottery_no].length);

        return sticketno;
    }

    /**
    * Allows a ticket owner to reveal their random number for a lottery.
    * Verifies the ticket's ownership, quantity, and the hash of the provided random number.
    * @param lottery_no The ID of the lottery where the ticket belongs.
    * @param sticketno The ticket number to reveal the random number for.
    * @param rnd_number The random number provided by the ticket holder to be revealed.
    */
    function revealRndNumberTx(
        uint lottery_no,
        uint sticketno,
        // uint quantity
        uint rnd_number
    )   public
        lotteryControl(lottery_no) {

        LotteryStorage.State storage s = LotteryStorage.getStorage();
        LotteryStructs.Ticket storage ticket = s.lotteryTickets[lottery_no][sticketno];

        require(s.lotteries[lottery_no-1].state == LotteryStructs.LotteryState.REVEAL, "Lottery is not REVEAL state");
        require(sticketno <= s.lotteryTickets[lottery_no].length,"Ticket does not exist");
        
        require(!ticket.revealed, "Ticket already revealed"); // Ensure the ticket hasn't been revealed already

        // Verify that hash of provided rnd_number matches the committed hash
        bytes32 hash_rnd_number = keccak256(abi.encodePacked(rnd_number));
        require(
            (ticket.hash == keccak256(abi.encodePacked(hash_rnd_number, msg.sender))),
            "You revealed a wrong number"
        );

        ticket.revealed = true;
        s.lotteries[lottery_no-1].currentRandom ^= rnd_number; // To determine the winners fairly
    }

    /**
    * Allows a ticket owner to withdraw a refund if the lottery was canceled and tthe owner reveals its random number in the reveal stage.
    * @param lottery_no The ID of the lottery.
    * @param sticket_no The ticket number for which the refund is being claimed.
    */
    function withdrawTicketRefund(
        uint lottery_no,
        uint sticket_no
    )   public
        lotteryControl(lottery_no) {

        LotteryStorage.State storage s = LotteryStorage.getStorage();
        LotteryStructs.Lottery storage lottery = s.lotteries[lottery_no-1];
        LotteryStructs.Ticket storage ticket = s.lotteryTickets[lottery_no][sticket_no];

        require(lottery.state == LotteryStructs.LotteryState.CANCELLED, "Refunds not available for this lottery");
        require(sticket_no < s.lotteryTickets[lottery_no].length);
        require(ticket.owner == msg.sender, "You are not the owner of this ticket");
        require(ticket.revealed, "Random number not revealed");
        require(!ticket.redeemed, "Refund already claimed");
        
        // Mark the ticket as redeemed
        ticket.redeemed = true;
        
        // Calculate refund amount
        uint256 refundAmount = ticket.quantity * lottery.ticketprice;

        // Transfer refund to the ticket owner
        TicketToken ticketToken = TicketToken(address(this));
        require(ticketToken.transfer(msg.sender, refundAmount), "Refund failed");
    }
}