// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "./LotteryStructs.sol";
import "./TicketToken.sol";

/*
    The CompanyLotteries contract manages a lottery system that uses an ERC20 token (represented by the TicketToken contract)
    for ticket purchases. It allows for the creation of lotteries, ticket purchases, random number revelations, state changes, and more.
    The contract tracks multiple lotteries, their state, the participants, and the tickets they purchase.
    It also includes functionality for updating lottery states, revealing winners, and handling refunds in case of cancellations.
*/
contract CompanyLotteries {
    
    using LotteryStructs for *; // Using the Lottery, Ticket structs and LotteryState enum

    TicketToken public ticketToken;  
    address public tokenAddress;  // NBG token address

    address public owner;
    uint256 public currentLotteryNo;

    // Arrays of lottery IDs to Lottery
    LotteryStructs.Lottery[]  public lotteries;
    // Mapping of lottery IDs to an array of Ticket structs
    mapping(uint256 => LotteryStructs.Ticket[]) public lotteryTickets; 

    /*
    Sets the owner and initializes TicketToken contract.
    @param _ticketTokenAddress address of the deployed TicketToken contract
    */
    constructor(address _ticketTokenAddress) {
        owner = msg.sender;
        tokenAddress = _ticketTokenAddress;
        ticketToken = TicketToken(_ticketTokenAddress);
    }

    // Modifier to control functions that can be called by the owner only
    modifier onlyOwner() {
        require(msg.sender == owner, "Only the owner can call this function");
        _;
    }

    // Event to track created lotteries
    event LotteryCreated(uint lottery_no, uint unixbeg, uint nooftickets); 

    // Event to notify that winners have been determined
    event WinnersDetermined(uint256 lottery_no, uint256[] winners);

   /*
    Creates a new lottery with Lottery Struct.
    @param unixbeg End time of the lottery (in Unix timestamp)
    @param noOfTickets Total number of tickets in the lottery
    @param noOfWinners Number of winners to be selected
    @param minPercentage Minimum percentage of tickets to be sold for the lottery to be valid
    @param ticketPrice Price of each ticket (in the NBG Token)
    @returns currentLotteryNo Lottery number of created lottery
    */
    function createLottery(
        uint unixbeg,
        uint nooftickets,
        uint noofwinners,
        uint minpercentage,
        uint ticketprice,
        bytes32 htmlhash,
        string memory url
    ) public onlyOwner returns (uint lottery_no) {

    require(noofwinners > 0);
    require(minpercentage <= 100);
    uint256 currenttime = block.timestamp;
    require(unixbeg > currenttime);

    currentLotteryNo++;

    lotteries.push(LotteryStructs.Lottery({
        unixbeg: unixbeg,
        nooftickets: nooftickets,
        noofwinners: noofwinners,
        minpercentage: minpercentage,
        ticketprice: ticketprice,
        htmlhash: htmlhash,
        url: url,
        revealStartTime: currenttime + ((unixbeg - currenttime) / 2),  // half the time of total
        state: LotteryStructs.LotteryState.PURCHASE,
        numsold: 0,
        numpurchasetxs: 0,
        currentRandom: 0,
        lotteryWinners: new uint256[](noofwinners)  // Initialize winners array with the number of winners
    }));
 
    emit LotteryCreated(currentLotteryNo, unixbeg, nooftickets); 
    return currentLotteryNo;
    }

   /*
    Allows a user to purchase tickets for a specified lottery.
    This function ensures the lottery is active, there are enough tickets available, 
    and processes the purchase by transferring the total cost in tokens.
    It also creates a ticket for the user and updates the lottery state.
    @param lottery_no Lottery which the ticket will be purchased
    @param quantity Number of tickets to be purchased
    @param hash_rnd_number Hash generated by the user by using their address and random number
    @return sticketno The ticket number for the first ticket purchased (the index of the first ticket in the array).
    Emits a `TicketPurchased` event to track the ticket purchase.
    */
    function buyTicketTx(
        uint lottery_no,
        uint quantity,
        bytes32 hash_rnd_number
    ) public returns (uint sticketno) {

        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;   
        // Check if the lottery is active, lottery is finished, and are there enough tickets to sold
        require(
            lotteries[arrayIndex].state == LotteryStructs.LotteryState.PURCHASE,
            "Lottery is not active"
        );
        require(
            block.timestamp < lotteries[arrayIndex].revealStartTime,
            "Lottery sale is done"
        );
        require(
            quantity <= 30,
            "You can purchase at most 30 tickets. "
        );
        require(
            lotteries[arrayIndex].numsold + quantity <= lotteries[arrayIndex].nooftickets,
            "Not enough tickets available"
        );

        // Calculate total cost and transfer token from user to the company account.
        //uint256 totalCost = quantity * lotteries[arrayIndex].ticketprice;
        // Transfer token from  msg.sender to company address.
        //ticketToken.transferFrom(msg.sender, address(this), totalCost);

        lotteries[arrayIndex].numsold += quantity;
        //update purchase transactions
        lotteries[arrayIndex].numpurchasetxs += 1;

        lotteryTickets[lottery_no].push(LotteryStructs.Ticket({
            owner: msg.sender,
            quantity: quantity,
            hash: keccak256(abi.encodePacked(hash_rnd_number, msg.sender)),
            revealed: false,
            redeemed: false
        }));  
        sticketno =  uint32(lotteryTickets[lottery_no].length);
    }

    /*
    Allows a ticket owner to reveal their random number for a lottery.
    Verifies the ticket's ownership, quantity, and the hash of the provided random number.
    @param lottery_no The ID of the lottery where the ticket belongs.
    @param sticketno The ticket number to reveal the random number for.
    @param quantity The number of tickets purchased (should match the ticket's quantity).
    @param rnd_number The random number provided by the ticket holder to be revealed.
    */
    function revealRndNumberTx(
        uint lottery_no,
        uint sticketno,
        //uint quantity,
        uint rnd_number
    ) public {
        require(lottery_no > 0 );
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;   
        require(
            lotteries[arrayIndex].state == LotteryStructs.LotteryState.REVEAL,
            "Lottery is not REVEAL state"
        );
        require(
            sticketno <= lotteryTickets[lottery_no].length,
            "Ticket does not exist"
        );
        // Ensure the ticket hasn't been revealed already
        require(!lotteryTickets[lottery_no][sticketno].revealed, "Ticket already revealed");
        // Verify that hash of provided rnd_number matches the committed hash
        bytes32 hash_rnd_number = keccak256(abi.encodePacked(rnd_number));
        require(
            (lotteryTickets[lottery_no][sticketno].hash == keccak256(abi.encodePacked(hash_rnd_number, msg.sender))),
            "You revealed a wrong number"
        );
        lotteryTickets[lottery_no][sticketno].revealed = true;
        // To determine the winners fairly
        lotteries[arrayIndex].currentRandom ^= rnd_number;
    }

    /*
    Retrieves the number of purchase Transactions a specific lottery.
    @param lottery_no Lottery ID which is used to retrieve information about its transactions.
    @return numpurchasetxs Number of transactions
    */
    function getNumPurchaseTxs(uint lottery_no) public view returns (uint numpurchasetxs) {
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;   
        return lotteries[arrayIndex].numpurchasetxs;
    }

    /*
    View function to get information of a ticket.
    Allows anyone to view the quantity of tickets purchased in the Ith transaction for a specified lottery
    @param i Ticket index number (starts with 1 as first)
    @param lottery_no lottery number which the ticket is in
    @return sTicketNo Sold ticket no
    @return quantity Quantity of tickets sold
    */
    function getIthPurchasedTicketTx(uint i, uint lottery_no) public view returns (uint sticketno, uint quantity) {         
        // Check if the number of ticket is more than total ticket sold
        require(i <= lotteryTickets[lottery_no].length);
        // Access the ticket information
        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][i];
        return (i, ticket.quantity);
    }

    /*
    Function to check if a specific ticket has won in a specified lottery.
    This function assumes the winners are determined and marked in some way 
    @param lottery_no The ID of the lottery.
    @param ticket_no The ticket number to check (starting from 0 for the first ticket).
    @return won A boolean indicating whether the specified ticket has won.   
    */
    function checkIfMyTicketWon(uint lottery_no, uint ticket_no) public view returns (bool won) {
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        require(lottery_no <= currentLotteryNo, "Invalid lottery number");
    
        require(
            lotteries[arrayIndex].state == LotteryStructs.LotteryState.COMPLETED,
            "Lottery is not COMPLETED state"
        );
        
        require(
            ticket_no < lotteryTickets[lottery_no].length,
            "Invalid ticket number"
        );

        LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][ticket_no];
        // Verify that the caller owns the ticket
        require(ticket.owner == msg.sender, "You do not own this ticket");
        require(
            ticket.revealed == true ,
            "You did not submitted your random number. "
        );

        // Check if ticketNo is in the list of winners for the lottery
        for (uint256 i = 0; i < lotteries[arrayIndex].lotteryWinners.length;i++) {
            if (lotteries[arrayIndex].lotteryWinners[i] == ticket_no) {
                return true;
            }
        }
        return false;
    }

    /*
    Checks if a specific ticket owned by a given address has won in a specified lottery.
    @param addr The address of the ticket owner.
    @param lottery_no The ID of the lottery.
    @param ticket_no The ticket number to check (starting from 0 for the first ticket).
    @return won A boolean indicating whether the specified ticket has won.
    */
    function checkIfAddrTicketWon(address addr, uint lottery_no, uint ticket_no) public view returns (bool won){
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        require(lottery_no <= currentLotteryNo);
        require(ticket_no <= lotteryTickets[lottery_no].length);

        require(
            lotteryTickets[lottery_no][ticket_no].revealed == true ,
            "The address was not submitted its random number. "
        );
        // Check if ticketNo is in the list of winners for the lottery
        for (uint256 i = 0; i < lotteries[lottery_no].lotteryWinners.length;i++) {
            if (lotteries[arrayIndex].lotteryWinners[i] == ticket_no) {
                LotteryStructs.Ticket storage ticket = lotteryTickets[lottery_no][ticket_no];
                if (ticket.owner == addr) {
                    return true;
                }
            }
        }
        return false;
    }


    /*
    Retrieves the ticket number of the i-th winning ticket in a specific lottery.
    @param lottery_no The ID of the lottery.
    @param i The index of the winning ticket (starting from 1 for the first winner).
    @return ticketno The ticket number of the i-th winner.
    */
    function getIthWinningTicket(uint lottery_no, uint i) public view returns (uint ticketno) {
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        require(lottery_no <= currentLotteryNo);
        require(
            lotteries[arrayIndex].state == LotteryStructs.LotteryState.COMPLETED,
            "Lottery has not been completed"
        );
        // Ensure the i-th winner index is within the number of winners
        require(i > 0 && i <= lotteries[arrayIndex].noofwinners);
        // Adjust index to match array (0-based index)
        uint winnerIndex = i - 1;
        // Retrieve the winning ticket's index
        ticketno = lotteries[arrayIndex].lotteryWinners[winnerIndex];
        return ticketno;
}

    /*
    Allows a ticket owner to withdraw a refund if the lottery was canceled and tthe owner reveals its random number in the reveal stage.
    @param lottery_no The ID of the lottery.
    @param sticket_no The ticket number for which the refund is being claimed.
    */
    function withdrawTicketRefund(uint lottery_no, uint sticket_no) public {
        require(lottery_no > 0 );
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;    

        require(lottery_no <= currentLotteryNo);

        LotteryStructs.Lottery storage lottery = lotteries[arrayIndex];

        // Ensure the lottery is in a refundable state
        require(
            lottery.state == LotteryStructs.LotteryState.CANCELLED ,
            "Refunds not available for this lottery"
        );

        require(sticket_no < lotteryTickets[lottery_no].length);

        // Ensure the caller owns the ticket
        require(lotteryTickets[lottery_no][sticket_no].owner == msg.sender, "Not owner");

        // Ensure the caller reveals its random number at reveal stage
        require(
            lotteryTickets[lottery_no][sticket_no].revealed == true, 
            "You did not submitted your random number "
            );

        // Ensure the ticket hasn't been refunded already
        require(!lotteryTickets[lottery_no][sticket_no].redeemed, "already refunded");

        // Calculate refund amount
        uint256 refundAmount = lotteryTickets[lottery_no][sticket_no].quantity * lottery.ticketprice;
        // Mark the ticket as redeemed
        lotteryTickets[lottery_no][sticket_no].redeemed = true;
        // Transfer refund to the ticket owner
        require(ticketToken.transfer(msg.sender, refundAmount), "Refund failed");

    }

    /*
        Returns the current lottery number of the contract.
        @return currentLotteryNo Current Lottery number in the contract.
    */
    function getCurrentLotteryNo() public view returns (uint lottery_no) {
        return currentLotteryNo;
    }

    /*
    Allows the contract owner to withdraw the ticket proceeds from a specific lottery.
    This function is only callable by the contract owner and will transfer the proceeds to the owner's address.
    @param lottery_no The ID of the lottery for which the proceeds are being withdrawn.
    */
    function withdrawTicketProceeds(uint lottery_no) public onlyOwner {
        // Ensure the lottery exists and is completed
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        require(
            lotteries[arrayIndex].state == LotteryStructs.LotteryState.COMPLETED,
            "Lottery has not been completed"
        );

        LotteryStructs.Lottery storage lottery = lotteries[arrayIndex];

        // Calculate the total ticket sales proceeds
        uint256 totalProceeds = lottery.numsold * lottery.ticketprice;

        // Ensure the contract has sufficient funds
        uint256 contractBalance = ticketToken.balanceOf(address(this));
        require(contractBalance >= totalProceeds, "Insufficient funds");

        // Transfer the ticket proceeds to the contract owner
        require(ticketToken.transfer(owner, totalProceeds), "transfer failed");
    }


    /*
    Allows the contract owner to set or update the address of the ERC20 token used for ticket purchases.
    @param erctokenaddr The address of the new ERC20 token contract to be used for ticket payments.
    */
    function setPaymentToken(address erctokenaddr) public onlyOwner {
        require(erctokenaddr != address(0));
        // Set the new ERC20 token address
        ticketToken = TicketToken(erctokenaddr);
    }

    /*
    Retrieves the ERC20 token address used for ticket purchases in a specific lottery.
    @param lottery_no The ID of the lottery for which the payment token address is being retrieved.
    @return erctokenaddr The ERC20 token address used for ticket purchases in the specified lottery.
    */
    function getPaymentToken(uint lottery_no) public view returns (address erctokenaddr) {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        // Return the ERC20 token address used for ticket purchases in the specified lottery
        erctokenaddr = address(ticketToken);
    }

    /*
        Retrieves the essential information about a specific lottery based on its unique lottery ID
        @param lottery_no The ID of the lottery whose information is being requested
        @return unixbeg Start time of the lottery (in Unix timestamp)
        @return noOfTickets Total number of tickets in the lottery
        @return noOfWinners Number of winners to be selected
        @return minPercentage Minimum percentage of tickets to be sold for the lottery to be valid
        @return ticketPrice Price of each ticket (in the NBG Token)
    */
    function getLotteryInfo(uint256 lottery_no) public view
        returns (
            uint256 unixbeg,
            uint256 nooftickets,
            uint256 noofwinners,
            uint256 minpercentage,
            uint256 ticketprice
        )
    {    
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        // Access the LotteryInfo struct for the specified lottery number
        LotteryStructs.Lottery storage lottery = lotteries[arrayIndex];
        return (
            lottery.unixbeg,
            lottery.nooftickets,
            lottery.noofwinners,
            lottery.minpercentage,
            lottery.ticketprice
        );
    }

  

    /*
    Retrieves the URL and the associated hash (HTML hash) for a given lottery.
    This function allows users to fetch the URL and the HTML hash linked to a specific lottery.
 
    @param lottery_no The ID of the lottery whose URL and HTML hash are being queried.
                      It corresponds to a specific lottery stored in the `lotteries` mapping.

    @return htmlhash The bytes32 hash of the HTML content related to the lottery. This could represent a hash of a web page or resource related to the lottery.
    @return url The string URL associated with the lottery. This could be the link to the lottery's page or additional information about the lottery.
    */
    function getLotteryURL(uint lottery_no) public view returns (bytes32 htmlhash, string memory url) {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0 );
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        LotteryStructs.Lottery storage lottery = lotteries[arrayIndex];
        return (lottery.htmlhash, lottery.url);
    }

    /*
    Retrieves the number of ticket sold for a specific lottery.
    @param lottery_no Lottery ID which is used to retrieve information about its state and sold tickets
    @return soldTickets Number of purchased tickets in that particular lottery
    */
    function getLotterySales(uint lottery_no) public view returns (uint numsold)
    {   // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0 );
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        return lotteries[arrayIndex].numsold;
    }

    /*
    Determines the winners of a specific lottery. This function assumes that winners are selected
    based on a predetermined random number or another method.
    @param lottery_no The ID of the lottery for which the winners will be determined.
    @return winner_ticket_numbers An array of ticket numbers representing the winners.
    */
    function determineWinners(uint256 lottery_no) external onlyOwner {
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        // Ensure lottery is in the appropriate state
        require(lotteries[arrayIndex].state == LotteryStructs.LotteryState.COMPLETED, "Not been completed");

        // Ensure enough tickets were sold if a minimum percentage is required
        uint256 minTicketsRequired = (lotteries[arrayIndex].nooftickets * lotteries[arrayIndex].minpercentage) / 100;
        require(lotteries[arrayIndex].numsold >= minTicketsRequired, "Not enough tickets sold");

        uint256 totalTickets = lotteries[arrayIndex].numsold;
        uint256 numWinners = lotteries[arrayIndex].noofwinners;

        // Use currentRandom as the seed for winner determination
        uint256 randomSeed = lotteries[arrayIndex].currentRandom;

        // Select winners
        for (uint256 i = 0; i < numWinners; i++) {
            // Generate a pseudo-random number
            uint256 winnerIndex = uint256(keccak256(abi.encodePacked(randomSeed, i))) % totalTickets;
            // Ensure the winner is unique
            while (arrayContains(lotteries[arrayIndex].lotteryWinners, winnerIndex)) {
                winnerIndex = (winnerIndex + 1) % totalTickets;
            }
            // Add the winner to the list
            lotteries[arrayIndex].lotteryWinners[i] = winnerIndex;
        }
        // Emit an event for winner determination
        emit WinnersDetermined(lottery_no, lotteries[arrayIndex].lotteryWinners);
    }

    // Helper function to check if an array contains a specific value
    function arrayContains(uint256[] memory array, uint256 value) private pure returns (bool) {
        for (uint256 i = 0; i < array.length; i++) {
            if (array[i] == value) {
                return true;
            }
        }
        return false;
    }

    /**
    * Updates the states of all lotteries based on current conditions.
    * Transitions include:
    * - PURCHASE ➔ REVEAL if revealStartTime is reached.
    * - REVEAL ➔ COMPLETED if unixbeg is reached and minimum tickets are sold.
    * - Any state ➔ CANCELLED if unixbeg is reached and minimum tickets are not sold.
    */
    function updateLotteryStates() public {
        uint256 currentTime = block.timestamp;

        for (uint256 i = 0; i < currentLotteryNo; i++) {
            if ( lotteries[i].state == LotteryStructs.LotteryState.PURCHASE) {
                // Transition to REVEAL if revealStartTime is reached
                if (currentTime >=  lotteries[i].revealStartTime) {
                    lotteries[i].state = LotteryStructs.LotteryState.REVEAL;
                }
            } else if ( lotteries[i].state == LotteryStructs.LotteryState.REVEAL) {
                // Transition to COMPLETED if enough tickets sold, else CANCELLED
                if (currentTime >=  lotteries[i].unixbeg) {
                    uint256 minTicketsRequired = ( lotteries[i].nooftickets *  lotteries[i].minpercentage) / 100;
                    if ( lotteries[i].numsold >= minTicketsRequired) {
                         lotteries[i].state = LotteryStructs.LotteryState.COMPLETED;
                    } else {
                         lotteries[i].state = LotteryStructs.LotteryState.CANCELLED;
                    }
                }
            } else if (
                 lotteries[i].state == LotteryStructs.LotteryState.PURCHASE ||
                 lotteries[i].state == LotteryStructs.LotteryState.REVEAL)
            {
                // Cancel lotteries if end time passed and they haven't transitioned
                if (currentTime >=  lotteries[i].unixbeg) {
                    uint256 minTicketsRequired = ( lotteries[i].nooftickets * lotteries[i].minpercentage) / 100;
                    if ( lotteries[i].numsold < minTicketsRequired) {
                         lotteries[i].state = LotteryStructs.LotteryState.CANCELLED;
                    }
                }
            }
        }  
    }

   /*
        Retrieves the essential information about a specific lottery based on its unique lottery ID
        @param lottery_no The ID of the lottery whose information is being requested
        @return unixbeg Start time of the lottery (in Unix timestamp)
        @return noOfTickets Total number of tickets in the lottery
        @return noOfWinners Number of winners to be selected
        @return minPercentage Minimum percentage of tickets to be sold for the lottery to be valid
        @return ticketPrice Price of each ticket (in the NBG Token)
    */
    function getLotteryState(uint256 lottery_no) public view
        returns (
            LotteryStructs.LotteryState state
        )
    {    
        // Ensure the lottery exists
        require(lottery_no <= currentLotteryNo);
        require(lottery_no > 0);
        // Adjust lottery array index
        uint arrayIndex = lottery_no-1;  
        // Access the LotteryInfo struct for the specified lottery number
        LotteryStructs.Lottery storage lottery = lotteries[arrayIndex];
        return (
            lottery.state
        );
    }

}